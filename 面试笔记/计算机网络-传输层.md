# 计算机网络-传输层

## 概述

### 传输层 VS 网络层

1. 网络层提供主机之间的逻辑通信

2. 传输层提供应用层之间的逻辑通信机制
    - 位于网络层之上
    - 依赖于网络层服务
    - 对网络层服务进行（可能的）增强

### Internet传输层协议

1. 可靠、按序的交付服务（TCP）

    - 拥塞控制
    - 流量控制
    - 连接建立
2. 不可靠的交付服务（UDP）
    - 没有做可靠性方面的扩展
3. 两种都不提供延迟和带宽上的保证

---

## 多路复用和多路分用

1. 接收端进行多路分用

    - 传输层依据头部信息将收到的Segment交给正确的Socket,及不同的进程
    - 工作机制：主机收到Segment之后，传输层协议提取IP地址和端口号信息，将Segment交给Socket，TCP要做更多的处理
    - UDP的Socket用二元组表示（目的IP地址， 目的端口号）
    - 主机收到UDP段后，检查段中的目的端口号，将UDP段导向在该端口号的Socket====来自不同的IP地址和源端口号的IP数据包被导向同一个Socket
    - TCP的Socket有四元组表示（源IP地址， 源端口号，目的IP地址， 目的端口号）
    - 接收端利用四个值将Segment导向合适的Socket,服务器可能同时支持多个TCP Socket,其每个Socket都有自己的四元组表示====web服务器为每个户端开不同的Socket(多线程)
2. 发送端进行多路复用

    - 从多个Socket接收数据，为每块数据封装上头部信息，生成Segment，交给网络

---

## UDP（用户数据报协议）

### 基于Internet IP协议

- 复用/分用
- 简单的错误检验

### "Best effort"服务,UDP端可能

- 丢失
- 非按序到达

### 无连接

- UDP发送方与接受方不需要握手
- 每个UDP段的处理独立于其他段

#### UDP为什么存在

- 无需建立连接（减少延迟）
- 实现简单：无需维护连接状态
- 头部开销小
- 没有拥塞控制：应用可更好地控制发送时间和速率

### 常用于流媒体

- 容忍丢失
- 速率敏感

### UDP还用于

- DNS
- SNMP

### 在UDP上实现可靠的数据传输

- 在应用层增加可靠性机制
- 应用特定的错误恢复机制

#### UDP结构

- 源端口
- 目的端口
- UDP端长度
- 检验和（检测在UDP传输过程中是否发生错误）
- 应用数据

---

## 可靠数据传输的基本原理（不错、不乱、不丢）

### rdt1.0

1. 底部信道完全可靠
    - 不会发生错误
    - 不会丢弃分组
2. 因此发送方和接收方完全独立，不需要通信，只等应用层和网络层的调用

### rdt2.0(产生位错误的信道)

1. 发现错误 -> 利用检验和检测位错误
2. 错误恢复
    - ACK:告知发送方已正确接受
    - NAK:告知接受方分组有错误
    - 发送方收到NAK后，重传分组
3. 引入的新机制
    - 差错重传
    - 接收方返回控制消息:ACK/NAK
    - 重传
4. 状态变化啊
    - 发送方： 等待调用-发送数据->等待ACK ot NAK -检验消息,若错误则重传，正确则回到等待调用
    - 接收方：等待调用-如果正确，发送ACK,错误，发送NAK->继续等待

### rdt2.1和2.2(发送方收到的ACK或NAK可能也会坏掉)
1. 为ACK\NAK添加检验和，判断ACK/NAK是否被破坏
2. 如果发送方接受的的ACK/NAK坏掉了，发送方还是继续重发，这样会引起重复分组
3. 解决重复分组->利用序列号：发送方给每个分组增加序列号,接受方丢弃重复分组即可

#### rdt2.1
- 发送方发送（序号，数据，检验和）
    * 开始等待接收方的回复
- 接收方接受
    * 检验文件是否丢失、序号是否对应
        - 文件丢失 -> 发送NAK,检验和
        - 序号不对应 -> 发送ACK,检验和(非本序号)
    * 正确无误
        - 发送ACK,检验和（本序号）
        - 继续接收下一个数据
- 发送方接受接收方的回复
    * 如有错误继续重发
    * 如正确等待发送下一个数据

#### rdt2.2
- 在rdt2.1的基础上取消了NAK消息发送
- 接收方在放松信息时要将分组的序号加上
- 发送方需要判断回复信息的序号和自己发送序号是否相同，不同则重传

### rdt3.0(产生位错误的信道,丢失分组)

 - 丢失分组接收方不发送ACK消息，因此在此基础上加上计时器功能
 - 当发送分组时，开始计时，直到收到ACK回复，停止计时，如果丢包，那么就会超时，发送方就重传
 - 但是该协议限制了物理资源的利用（停-等）

## 流水线机制和滑动窗口机制
- 由于rdt的限制，为了提高物理资源的利用，我们采用了以上两种机制
- 流水线机制
    * 一次发送多个分组，因此要扩大序列号范围，两边需要更大的控件缓存分组数据
- 滑动窗口机制
    * 每次允许发送的分组是有上限的，窗口中的分组是正在进行传输的，如果有正确完成传输的就退出窗口，让未进行传输的分组进入窗口进行传输
### Go-Back-N协议
#### 发送方
- 窗口尺寸为N，N个分组一起发送
- ACK（n）:确认到序列号n（包含n)的分组均已被正确接收
    * 可能收到重复的ACK
- 每发一次有一个计时器
- 超时后：重传序列号等于n,还为收到ACK的所有分组
#### 接收方
- ACK机制：发送拥有最高序列号的、已被正确接收的分组的ACK
    * 可能有重复的ACK
    * 只需要记住唯一的异常序列数
- 乱序到达的分组
    * 直接丢弃->接收方没有缓存
    * 重新确认序号最大的、按序到达的分组

### Selective Repeat协议

- GNB缺陷
    * 重复分组过多
- 接收方对每个分组单独进行确认
    * 设置缓存机制，缓存乱序到达的分组
- 发送方只发送没有收到ACK的分组
    * 为每个分组设置定时器
- 发送窗口
    * N个连续的序列号
    * 限制已发送未确认的分组
- SR协议困境
    * 序列号空间大小于窗口的关系

## TCP

### 概述
- 点对点
    * 一个发送方，一个接收方
- 可靠的、按序的字节流
- 流水线机制
    * TCP拥塞控制流量控制机制设置窗口大小
- 发送方/接收方缓存
- 全双工
    * 同一连接中能够传输双向数据流
- 面向连接
    * 通信双方在发送数据之前必须建立连接
    * 连接状态只在连接的两端中维护，在沿途节点中并不维护状态
    * TCP连接包括：两台主机上的缓存、连接状态变量、socket等
- 流量控制机制

- TCP数据端结构
![img](https://img-blog.csdn.net/20180717201939345?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


字段|	含义
---|---
URG	|紧急指针是否有效。为1，表示某一位需要被优先处理
ACK	|确认号是否有效，一般置为1。
PSH	|提示接收端应用程序立即从TCP缓冲区把数据读走。
RST	|对方要求重新建立连接，复位。
SYN	|请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
FIN  |  	希望断开连接。


### 可靠数据传输概述
- 流水线机制
- 累积确认
- TCP使用单一重传定时器
- 出发重传机制
    * 超时
    * 收到重复的ACK
- 如何设置超时时长
    * 大于RTT，那么怎么估计RTT
        - 通过多个RRT样本进行估计（估计值 = 估计值 * 系数（0.125）+ + 系数 * 采样值）
    * 测量RTT的变化值为DevRTT
    * 超时时间 = 估计值 + DevRTT

#### TCP发送方事件
- 从应用层收到数据
    * 创建Segment
    * 序列号是Segment第一个字节的编号
    * 开启计时器
    * 设置超时时间
- 处理事件
    * 超时
        - 重传引起超时的Segment
        - 重启定时器
    * 收到ACK
        - 如果确认此前未确认的Segment
            - 更新SendBase
            - 如果窗口中还有未被确认的分组。重新起到定时器
#### TCP接收方事件


### 快速重传机制
- 如果收到重复的ACk3个在定时器超时前会进行重传

### TCP流量控制
- 接收方会在Segment的头部字段将RcvWindow告诉Sender，Sender开始控制自己发送的数据不超过接收方剩余的空间‘
- 问题：当空闲空为0时会怎么样

### TCP的连接管理

#### 建立连接

- 图示连接过程
![连接过程](https://upload-images.jianshu.io/upload_images/10274426-8103f41564c05726?imageMogr2/auto-orient/strip|imageView2/2/w/843/format/webp)

- 详细过程
    * 服务器处于监听状态，等待客户端的连接请求
    * 客户端向服务器发送请求，在报文中将SYN置为1，生成序列号(假设为x)，接着处于等待接收服务器的回应(SYN_SEND)
    * 服务器接收发到客服端的报文，接着向客服端发送报文，将SYN置为1随机生成序列号y,并将ackz置x+1，接着等待客服端的回应(SYN_RCVD)
    * 客服端接收到确认信息后，将ACK置为y+1，序列号为上一个报文段加一（x+1）准备传输数据
    * 服务器接收到客服端的应答信息后，将转变到数据传输状态

- 为什么连接是三次而不是两次
    * 为了防止那些第一次发送的报文由于在传输过程中未能准时到达，而客户端终止了此次连接，开始了新的连接操作后，而服务器收到该无效报文时却不知到接收的该连接报文已经无效，那么就会除据数据传输的状态而且不会再收到关闭连接，导致服务器长期开起无效服务而拜拜浪费资源，所以服务器必须再次接收确认信息才能保证此次传输双方连接成功

- 三次连接的作用
    * 确认双方的接收、发送能力是否正常
    * 确认双方的序列号为数据传输做准备
    * 如果是HTTPs协议的话，在三次连接中还会进行数字证书的验证和加密秘钥的生成

#### 断开链接额

- 图示过程
![img](https://upload-images.jianshu.io/upload_images/10274426-34a7d621e9d5cedc?imageMogr2/auto-orient/strip|imageView2/2/w/980/format/webp)

- 详细过程
    * 若客户端想断开连接，会向服务器发送一个断开连接的报文，其中将FIN置为1，序列号为上个传输报文序列号加一，此时客服端处于FIN_WAIT_1状态
    * 服务器接收到该报文后将发送回应报文，其中ACK置为1，序号为上传输的报文加一，和ack置为接收到的报文序号加一，服务器处于CLOSE_WAIT状态
    * 当客户端接收到确认报文后，开始处于FIN_WAIT_2状态，此时客服端到服务器的连接已经断开，处于半连接状态，而服务器还可以向客户端发送数据，等待服务器的请求断开报文。
    * 服务器想断开连接时，服务器会向客服端发送断开连接的报文，此时服务器处于LAST_ACK状态的，其中将FIN置为1，ACK置为1，序号为u,ack为x+1,等待客服端的应答
    * 客户端接收到后会发送ACK报文将ACK置为1，序号为x+1,ack=u+1,发送后客户端处于TIME_WAIT(等待2MSL--报文存在的最长时间)之再关闭连接，而服务器收到ACK应答就处于关闭状态

### 拥塞控制